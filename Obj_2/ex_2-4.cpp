#include <conio.h>

int main()
{
    /*
        关于const引用的小九九:
        如果const int &ri, 这样的一个引用在初始化时可以被赋值很多类型的数据, 比如说整数, 整数变量, 甚至是双精度浮点数double, 只不过在赋值double时C++编译器会创建一个临时的temp变量, 将double类型变换成const int类型, 然后再赋值引用, 简称没用.
        总结: 指向常量类型的指针或引用不能通过自身来赋值, 但不代表着被指向或被引用的对象不能被改变, 并且常量指针或常量引用在初始化后是不能改变指向另一个对象的, 被锁死了.
        const int *const pip: 这种指的是pip是一个常量指针, 他指向了一个常量对象;
    */

    /*
        exam 2.42:
        //
        1. 不合法, 引用不能初始化为常数或者是一个字面值, 引用必须初始化一个对象.
        2. 合法
        3. 不合法
        4. 合法
        5. 合法
        6. 不合法, 引用必须初始化一个对象
        7. 不合法, 常量对象必须用常量引用.

        //
        1. 不合法, 常量指针必须初始化一个对象
        2. 不合法, 如上
        3. 不合法, 常量对象必须用常量引用
        4. 不合法, 如上
        5. 合法, 定义了个指针, 指向一些常量int数据类型, 不过还没有初始化, 这是合法的.
    */

    /*
        exam 2.43
        //
        顶层, 非常量, 非常量, 非常量, 底层, 顶层

        看一个东西是顶层还是底层, 得看定义时有没有const, 和赋值没有关系, 即使指向的对象是顶层, 他也不会将顶层const这个属性赋值过去, 只会将值复制过去;
        
    */

    _getch();
    return 0;
}